---
layout: post
title: "前端开发整理"
date: 2025-08-05
categories: [技术杂谈]
tags: [技术，前端]
published: true
mermaid: true
math: true
---

# 前端工程化

## 前端工程化需要遵循的一些规范

前端工程化代码的常用结构：

```plaintext
src -> 目录
src/main.ts -> 入口文件
src/views -> 路由组件目录
src/components -> 子组件目录
src/router -> 路由目录
```

在写属性时，尽可能一个属性占一行；同时对多种正确的语法方式要确定一种作为标准

## Vue.js与工程化

Vue 的编程方式被称为 “数据驱动” 编程，通过操作虚拟 DOM （ Virtual DOM ，简称 VDOM ），每一次数据更新都通过 Diff 算法找出需要更新的节点，只更新对应的虚拟 DOM ，再去映射到真实 DOM 上面渲染，以此避免频繁或大量的操作真实 DOM 。

> **DOM(Document Object Model,文档对象模型)**
> **DOM**（文档对象模型，Document Object Model）是**浏览器用来表示和操作网页内容的一种树状结构模型**。  
> DOM 把网页看作一个由节点组成的树状结构，页面上的每一个元素（如`<div>`、`<p>`、文本、属性等）都被看作是一个节点（Node），JavaScript 可以通过 DOM 来动态访问、修改网页结构、样式和内容。  
> 这是一个html示例：  
> ```html  
> <html>  
>   <body>  
>     <h1>Hello</h1>  
>     <p>World</p>  
>   </body>  
> </html>  
> ```  
> 这是对应的css示例：  
> ```css  
> Document  
> └── html  
>     └── body  
>         ├── h1  
>         │   └── "Hello"  
>         └── p  
>             └── "World"  
> ```  
> 进而则可以用`javascript`修改：  
> ```js  
> document.querySelector('h1').textContent = 'Hi!';  
> ```  
> 虚拟 DOM 则是指将原本应该是真实 DOM 元素的 UI 界面，用数据结构来组织起完整的 DOM 结构，再同步给真实 DOM 渲染，减少浏览器的回流与重绘。
{: .prompt-info } 

Vue 3.0 版本还引入了组合式 API 的概念，更符合软件工程 “高内聚，低耦合” 的思想，让开发者可以更灵活的管理自己的逻辑代码，更方便的进行抽离封装再复用。

## 现代化开发理念

### MPA与SPA

#### MPA(Multi-Page Application，多页面应用)

MPA 多页面应用是最传统的网站体验，当一个网站有多个页面时，会对应有多个实际存在的 HTML 文件，访问每一个页面都需要经历一次完整的页面请求过程。

这种方法的优点：

- **首屏加载速度快**：MPA 页面源码写在 HTML 文件里， HTML 文件被访问成功，内容随即呈现
- **SEO友好**：因为网页的内容也影响收录，而MPA除TKD外网页其它内容也在HTML内
- **容易与服务端语言结合**：传统的页面都由服务端直出，可用 PHP 、 JSP 、 ASP 、 Python 等非前端语言或技术栈来编写页面模板，最终输出 HTML 页面到浏览器访问

这种方法的缺点：

- **页面之间的跳转访问速度慢**：每一次页面访问都需要完整的经历一次渲染过程
- **用户体验不够友好**：如果网页上资源较多或网速不好，就会明显卡顿或布局错乱
- **开发成本高**：传统的多页面模式缺少前端工程化的很多优秀技术栈支持，无法做到前后端分离来利用好跨岗位协作

> **TKD**  
> 网页的 TKD 三要素是指一个网页的三个关键信息，含义如下：  
> 1. T ，指 Title ，网站的标题，即网页的 <title>网站的标题</title> 标签。  
> 2. K ，指 Keywords ，网站的关键词，即网页的 <meta name="Keywords" content="关键词1,关键词2,关键词3" /> 标签。  
> 3. D ，指 Description ，网站的描述，即网页的 <meta name="description" content="网站的描述" /> 标签。
{: .prompt-info } 

#### SPA(Single-Page Application，单页面应用)

SPA 单页面应用是现代化的网站体验，不论站点内有多少个页面，在 SPA 项目实际上只有一个 HTML 文件，也就是 `index.html` 首页文件。它只有第一次访问的时候才需要经历一次完整的页面请求过程，之后的每个内部跳转或者数据更新操作，都是通过 AJAX 技术来获取需要呈现的内容并只更新指定的网页位置。

SPA 在页面跳转的时候，地址栏也会发生变化，主要有以下两种方式：

- 过修改 `Location:hash` 修改 `URL` 的 `Hash` 值（也就是 # 号后面部分），例如从 `https://example.com/#/foo` 变成 `https://example.com/#/bar`
- 通过 `History API` 的 `pushState` 方法更新 `URL` ，例如从 `https://example.com/foo` 变成 `https://example.com/bar`

SPA 的优点：

- 只有一次完全请求的等待时间（首屏加载）
- 用户体验好，内部跳转的时候可以实现 “无刷切换”
- 不需要重新请求整个页面，切换页面的时候速度更快
- 没有脱离当前页面，“页” 与 “页” 之间在切换过程中支持动画效果
- 脱离了页面跳页面的框架，整个网站形成一个 Web App ，更接近原生 App 访问体验
- 开发效率高，前后端分离，后端做 API 接口，前端做界面和联调，同步进行缩短工期

SPA 的缺点：

- **首屏加载相对较慢**：由于 SPA 应用的路由是由前端控制， SPA 在打开首页后，还要根据当前的路由再执行一次内容渲染
- **不利于 SEO 优化**：对搜索引擎来说，网站的内容再丰富，依然只是一个 “空壳” ，无法让搜索引擎进行内容爬取

### CSR与SSR

#### CSR(Client-Side Rendering，客户端渲染)

一种利用 AJAX 的技术，把渲染工作从服务端转移到客户端完成，不仅客户端的用户体验更好，前后端分离的开发模式更加高效；但其具有SPA首屏加载较慢、不利于 SEO 优化等缺点。

#### SSR(Server-Side Rendering，服务端渲染)

现代前端工程化里的 SSR 通常是指使用 Node.js 作为服务端技术栈；SSR 服务端渲染交给前端开发者来维护，利用 Node 提供的能力进行同构渲染，本身前后端都使用 JavaScript 编写，维护成本也大大的降低。

SSR 技术利用的**同构渲染方案（ Isomorphic Rendering ）**，指的是一套代码不仅可以在客户端运行，也可以在服务端运行，在一些合适的时机**先由服务端完成渲染（ Server-Side Rendering ）再直出给客户端激活（ Client-Side Hydration ）**，其优势在于：

- 更好的 SEO 支持，解决了 SPA 单页面应用的痛点
- 更快的首屏加载速度，保持了 MPA 多页面应用的优点
- 和 SPA 一样支持前后端分离，开发效率依然很高
- 更好的客户端体验，用户完全打开页面，本地访问过程中也可保持 SPA 单页面应用体验
- 统一的心智模型，由于支持同构，因此没有额外的心智负担

### Pre-Rendering 与 SSG

#### Pre-Rendering(预渲染)

预渲染只在构建的时候就完成了页面内容的输出（发生在用户请求前），因此构建后不论用户何时访问， HTML 文件里的内容都是构建的时候的那份内容，所以预渲染适合一些简单的、有一定的 SEO 要求但对内容更新频率没有太高要求、内容多为静态展示的页面；例如企业用于宣传的官网页面、营销活动的推广落地页都非常适合使用预渲染技术，现代的构建工具都提供了预渲染的内置实现。

#### SSG(Static-Site Generation, 静态站点生成)

基于预渲染技术，通过开放简单的 API 和配置文件，让开发者实现一个预渲染静态站点的技术方案，作为一些开箱即用的技术产品来简化开发过程中的繁琐步骤。

常见的 SSG 静态站点生成器有：基于 Vue 技术的 VuePress 和 VitePress ，自带了 Vue 组件的支持，还有基于 React 的 Docusaurus ，以及很多各有特色的生成器，例如 Jekyll 、 Hugo 等等。

### ISR 与 DPR

ISR 增量式的网站渲染，通过区分 “关键页面” 和 “非关键页面” 进行构建，优先预渲染 “关键页面” 以保证内容的最新和正确，同时缓存到 CDN ，而 “非关键页面” 则交给用户访问的时候再执行 CSR 客户端渲染，并触发异步的预渲染缓存到 CDN；DPR 分布式的持续渲染则是为了解决 ISR 方案下可能访问到旧内容的问题。

## 与Web前端关联的工程化开发

### 服务端开发

传统的认知里，如果一个前端工程师想自己搭建一个服务端项目，需要学习 Java 、 PHP 、 Go 等后端语言，还需要学习 Nginx 、 Apache 等 Web Server 程序的使用，并使用这些技术来开发并部署一个项目的服务端；**现在的前端工程师可以利用 Node.js ，单纯使用 JavaScript 或者 TypeScript 来开发一个基于 Node 的服务端项目**。

在 GitHub 开源社区也诞生了很多更方便的、开箱即用、功能全面的服务端框架，根据它们的特点，可以简单归类如下：

- 以 Express 、 Koa 、 Fastify 为代表的轻量级服务端框架， “短平快” ，对于服务端需求不高，但可能出现服务端搭的很乱以至于难以维护的情况
- 以 Nest （底层基于 Express ，可切换为 Fastify ）、 Egg （基于 Koa ）为代表的基于 MVC 架构的企业级服务端框架，基于底层服务进行了更进一步的架构设计并实现了代码分层，还自带了很多开箱即用的 Building Blocks ，开箱即用，对大型项目的开发更加友好

> 学习注意  
> Node.js 所做的事情是解决服务端程序部分的工作，如果涉及到数据存储的需求，学习 MySQL 和 Redis 的技术知识还是必不可少的。
{: .prompt-attention }

### App 开发

Hybrid App 的出现，使得前端开发者也可以使用 JavaScript / TypeScript 来编写混合 App ，只需要了解简单的打包知识，就可以参与到一个 App 的开发工作中;在 App 开发完毕后，使用 Hybrid 框架提供的 CLI 工具编译出 App 资源包，再根据框架提供的原生基座打包教程去完成 Android / iOS 的安装包构建，这个环节会涉及到原生开发的知识。

### 桌面程序开发

放在以前要开发一个 Windows 桌面程序，需要用上 QT / WPF / WinForm 等技术栈，还要学习 C++ / C# 之类的语言，对于只想在业余写几个小工具的开发者来说，上手难度和学习成本都很高，但在前端工程化的时代里，使用 JavaScript 或 TypeScript 也可以满足程序开发的需要。

这得益于 Electron / Tauri 等技术栈的出现，其中 Electron 的成熟度最高、生态最完善、最被广泛使用，除了可以构建 Windows 平台支持的 .exe 文件之外，对 macOS 和 Linux 平台也提供了对应的文件构建支持。

Electron 的底层是基于 Chromium 和 Node.js ，它提供了两个进程供开发者使用：

- **主进程**：它是整个应用的入口点，主进程运行在 Node 环境中，可以使用所有的 Node API ，程序也因此具备了和系统进行交互的能力，例如文件的读写操作
- **渲染进程**：负责与用户交互的 GUI 界面，基于 Chromium 运行，所以开发者得以使用 HTML / CSS / JavaScript 像编写网页一样来编写程序的 GUI 界面

一个程序应用只会有一个主进程，而渲染进程则可以根据实际需求创建多个，渲染进程如果需要和系统交互，则必须与主进程通信，借助主进程的能力来实现。

在构建的时候， Electron 会把 Node 和 Chromium 一起打包为一个诸如 .exe 这样的安装文件（或者是包含了两者的免安装版本），这样用户不需要 Node 环境也可以运行桌面程序。

### 应用脚本开发

构建一种拥有可视化 GUI 界面的程序，但有时候并不需要复杂的 GUI ，可能只想提供一个双击运行的脚本类程序给用户，现在的前端工程化也支持使用 JavaScript 构建一个无界面的应用脚本。

这里推荐一个工具 Pkg ，它可以把 Node 项目打包为一个可执行文件，支持 Windows 、 macOS 、 Linux 等多个平台，它的打包机制和 Electron 打包的思路类似，也是通过把 Node 一起打包，让用户可以在不安装 Node 环境的情况下也可以直接运行脚本程序。

# 实践工程化的流程与工具

## 时间工程化的流程

基于 Vue 3 的项目，目前广泛采用的方案包括：

| 常用方案      | Runtime          | 构建工具             | 前端框架            |
| :--------------: | :----------------: | :-----------------: | :-----------------: |
| 方案一 | Node | Webpack	 | Vue |
| 方案二 | Node | Vite | Vue |

方案一是比较传统并且过去项目使用最多的方案组合，但从 2021 年初随着 Vite 2.0 的发布，伴随着更快的开发体验和日渐丰富的社区生态，新项目很多都开始迁移到方案二。

## Node.js介绍

Node.js(简称 Node)是一个基于 Chrome V8 引擎构建的 JS 运行时(JavaScript Runtime)；它让 JavaScript 代码不再局限于网页上，还可以跑在客户端、服务端等场景。

Node 的巨大优势在于，使用一种语言就可以编写所有东西（前端和后端），不再花费很多精力去学习各种各样的开发语言。

> Runtime的解释  
> Runtime ，可以叫它 “运行时” 或者 “运行时环境” ，这个概念是指，项目的代码在哪里运行，哪里就是运行时。传统的 JavaScript 只能跑在浏览器上，每个浏览器都为 JS 提供了一个运行时环境，可以简单地把浏览器当成一个 Runtime ，Node 就是一个让 JS 可以脱离浏览器运行的环境。  
{: .prompt-info }

## 工程化的构建工具

目前已经有很多流行的构建工具，例如： Grunt 、 Gulp 、 Webpack 、 Snowpack 、 Parcel 、 Rollup 、 Vite … 每一个工具都有自己的特色。构建工具通常集 “语言转换 / 编译” 、 “资源解析” 、 “代码分析” 、 “错误检查” 、 “任务队列” 等非常多的功能于一身。

实际的项目里，要用到的 JavaScript 原生方法非常多，不可能手动去维护每一个方法的兼容性，所以这部分工作，通常会让构建工具来自动化完成，常见的方案就有 Babel 。在实际的开发中，构建工具可以更好地提高开发效率、提供自动化的代码检查、规避上线后的生产风险。

## 开发环境和生产环境

对构建工具而言，会有 “开发环境(development)” 和 “生产环境(production)” 之分。生产环境和开发环境最大的区别就是稳定：除非再次打包发布，否则不会影响到已部署的代码。